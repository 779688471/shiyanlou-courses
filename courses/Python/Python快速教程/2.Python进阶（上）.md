#Python进阶（上）

作者：Vamei 出处：http://www.cnblogs.com/vamei 欢迎转载，也请保留这段声明。谢谢！

Python基础介绍了基本概念，特别是对象和类。

进阶教程对基础教程的进一步拓展，说明Python的细节。希望在进阶教程之后，你对Python有一个更全面的认识。


##一、词典

之前我们说了，列表是Python里的一个类。一个特定的表，比如说nl = [1,3,8]，就是这个类的一个对象。我们可以调用这个对象的一些方法，比如 nl.append(15)。
我们要介绍一个新的类，**词典 (dictionary)**。与列表相似，词典也可以**储存多个元素**。这种储存多个元素的对象称为**容器(container)**。

###1、基本概念

常见的创建词典的方法:

```
&gt;&gt;&gt;dic = {&#39;tom&#39;:11, &#39;sam&#39;:57,&#39;lily&#39;:100}

&gt;&gt;&gt;print type(dic)
```

词典和表类似的地方，是包含有**多个元素**，每个元素以逗号分隔。但词典的元素包含有两部分，**键**和**值**，常见的是以字符串来表示键，也可以使用数字或者真值来表示键（不可变的对象可以作为键）。值可以是任意对象。键和值两者一一对应。

比如上面的例子中，‘tom’对应11，&#39;sam对应57，&#39;lily&#39;对应100

与表不同的是，词典的元素**没有顺序**。你**不能通过下标引用元素**。词典是**通过键来引用**。

```
&gt;&gt;&gt;print dic[&#39;tom&#39;]

&gt;&gt;&gt;dic[&#39;tom&#39;] = 30

&gt;&gt;&gt;print dic
```

构建一个新的空的词典：

```
&gt;&gt;&gt;dic = {}

&gt;&gt;&gt;print dic
```

在词典中增添一个新元素的方法：

```
&gt;&gt;&gt;dic[&#39;lilei&#39;] = 99

&gt;&gt;&gt;print dic
```

这里，我们引用一个新的键，并赋予它对应的值。

###2、词典元素的循环调用

```
dic = {&#39;lilei&#39;: 90, &#39;lily&#39;: 100, &#39;sam&#39;: 57, &#39;tom&#39;: 90}
for key in dic:
    print dic[key]
```

**在循环中，dict的每个键，被提取出来，赋予给key变量。**

通过print的结果，我们可以再次确认，dic中的元素是没有顺序的。

###3、词典的常用方法

```
&gt;&gt;&gt;print dic.keys()           # 返回dic所有的键

&gt;&gt;&gt;print dic.values()         # 返回dic所有的值

&gt;&gt;&gt;print dic.items()          # 返回dic所有的元素（键值对）

&gt;&gt;&gt;dic.clear()                # 清空dic，dict变为{}
```

另外有一个很常用的用法：

```
&gt;&gt;&gt;del dic[&#39;tom&#39;]             # 删除 dic 的‘tom’元素
```

**del**是Python中保留的关键字，用于删除对象。

与表类似，你可以用**len()**查询词典中的元素总数。

```
&gt;&gt;&gt;print len(dic)
```


##二、文本文件的输入输出

Python具有基本的文本文件读写功能。Python的标准库提供有更丰富的读写功能。

文本文件的读写主要通过**open()**所构建的文件对象来实现。

###1、创建文件对象

我们打开一个文件，并使用一个对象来表示该文件：

```
对象名 = open(文件名，模式)
```

最常用的模式有：

- **r** 打开只读文件，该文件必须存在。 
- **r+** 打开可读写的文件，该文件必须存在。 
- **w** 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。 
- **w+** 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 
- **a** 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。 
- **a+** 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 
- 上述的形态字符串都可以再加一个b字符，如rb、w+b或ab＋等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。

比如：

```
&gt;&gt;&gt;f = open(&#34;test.txt&#34;,&#34;r&#34;)
```


###2、文件对象的方法

读取：

```
content = f.read(N)          # 读取N bytes的数据

content = f.readline()       # 读取一行

content = f.readlines()      # 读取所有行，储存在列表中，每个元素是一行。
```

写入：

```
f.write(&#39;I like apple!\n&#39;)      # 将&#39;I like apple&#39;写入文件并换行
```

关闭文件：

```
f.close()   # 不要忘记关闭文件
```

##三、模块

我们之前看到了函数和对象。从本质上来说，它们都是为了更好的组织已经有的程序，以方便重复利用。

**模块(module)**也是为了同样的目的。在Python中，**一个.py文件就构成一个模块**。通过模块，你可以**调用其它文件中的程序**。

###1、引入模块

我们先写一个first.py文件，内容如下：

```
def laugh():
    print &#39;HaHaHaHa&#39;
```

再写一个second.py，并引入first中的程序：

```
import first   #将first文件引入

for i in range(10):
    first.laugh()
```

在second.py中，我们使用了first.py中定义的laugh()函数。

引入模块后，可以通过 **模块.对象** 的方式来调用引入模块中的某个对象。上面例子中，first为引入的模块，laugh()是我们所引入的对象。

Python中还有其它的引入方式：

```
import a as b             # 引入模块a，并将模块a重命名为b

from a import function1   # 从模块a中引入function1对象。调用a中对象时，我们不用再说明模块，即直接使用function1，而不是a.function1。

from a import *           # 从模块a中引入所有对象。调用a中对象时，我们不用再说明模块，即直接使用对象，而不是a.对象。
```

这些引用方式，可以方便后面的程序书写。

###2、搜索路径

Python会在以下路径中搜索它想要寻找的模块：

- 程序所在的文件夹

- 操作系统环境变量PYTHONPATH所包含的路径

- 标准库的安装路径

如果你有自定义的模块，或者下载的模块，可以根据情况放在相应的路径，以便Python可以找到。

###3、模块包

可以将功能相似的模块放在同一个文件夹（比如说this_dir）中，构成一个模块包。通过

```
import this_dir.module
```

引入this_dir文件夹中的module模块。

该文件夹中必须包含一个 **\_\_init\_\_.py** 的文件，提醒Python，该文件夹为一个模块包。\_\_init\_\_.py **可以是一个空文件**。


##四、函数的参数传递

我们已经接触过函数(function)的**参数(arguments)传递**。当时我们根据**位置**，传递对应的参数。我们将接触更多的参数传递方式。

回忆一下位置传递：

```
def f(a,b,c):
    return a+b+c

print(f(1,2,3))
```

在调用 f 时，1，2，3根据位置分别传递给了a,b,c。

###1、关键字传递

有些情况下，用位置传递会感觉比较死板。**关键字(keyword)传递是根据每个参数的名字传递参数**。关键字并不用遵守位置的对应关系。依然沿用上面f的定义，更改调用方式：

```
print(f(c=3,b=2,a=1))
```

关键字传递可以和位置传递混用。但位置参数要出现在关键字参数之前：

```
print(f(1,c=3,b=2))
```
 
###2、参数默认值

在**定义函数**的时候，使用形如a=19的方式，可以给参数赋予默认值(default)。如果该参数最终没有被传递值，将使用该默认值。

```
def f(a,b,c=10):
    return a+b+c

print(f(3,2))
print(f(3,2,1))
```

在第一次调用函数f时， 我们并没有足够的值，c没有被赋值，c将使用默认值10.

第二次调用函数的时候，c被赋值为1，不再使用默认值。

###3、包裹传递

在**定义函数**时，我们有时候并不知道调用的时候会传递多少个参数。这时候，包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会非常有用。

下面是**包裹位置传递**的例子：

```
def func(*name):
    print type(name)
    print name

func(1,4,6)
func(5,6,7,1,2,3)
```

两次调用，尽管参数个数不同，都基于同一个func定义。**在func的参数表中，所有的参数被name收集，根据位置合并成一个元组(tuple)**，这就是包裹位置传递。

为了提醒Python参数，name是包裹位置传递所用的元组名，在定义func时，**在name前加*号**。

下面是**包裹关键字传递**的例子：

```
def func(**dict):
    print type(dict)
    print dict

func(a=1,b=9)
func(m=2,n=1,c=11)
```

与上面一个例子类似，dict是一个字典，收集所有的关键字，传递给函数func。为了提醒Python，参数dict是包裹关键字传递所用的字典，**在dict前加** \* \*。

包裹传递的关键在于**定义函数时**，在相应元组或字典前加 \* 或 \* \* 。

###4、解包裹

 \* 和 \*\*，也可以在**调用的时候**使用，即**解包裹(unpacking)**, 下面为例：

```
def func(a,b,c):
    print a,b,c

args = (1,3,4)
func(*args)
```

在这个例子中，所谓的解包裹，**就是在传递tuple时，让tuple的每一个元素对应一个位置参数**。在调用func时使用 \* ，是为了提醒Python：我想要把args拆成分散的三个元素，分别传递给a,b,c。（设想一下在调用func时，args前面没有 \* 会是什么后果？）

相应的，也存在对词典的解包裹，使用相同的func定义，然后：

```
dict = {&#39;a&#39;:1,&#39;b&#39;:2,&#39;c&#39;:3}
func(**dict)
```

&gt; 在传递词典dict时，让词典的每个键值对作为一个关键字传递给func。

###5、混合

在定义或者调用参数时，参数的几种传递方式可以混合。但在过程中要小心前后顺序。基本原则是：**先位置，再关键字，再包裹位置，再包裹关键字**，并且根据上面所说的原理细细分辨。

&gt; 注意：请注意定义时和调用时的区分。包裹和解包裹并不是相反操作，是两个相对独立的过程。

## 作业

####1、按照过程，在实验楼环境下运行本节所有代码，并截图。

####2、建立一个record.txt的文档，写入内容如下:

```
tom, 12, 86
Lee, 15, 99
Lucy, 11, 58
Joseph, 19, 56
```

再从 record.txt 中读取文件并打印。





