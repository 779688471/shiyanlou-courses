# 实验4-做2048游戏

## 一、实验说明


### 1. 环境登录

无需密码自动登录，系统用户名shiyanlou

### 2. 环境介绍

本实验环境采用带桌面的Ubuntu Linux环境，实验中会用到桌面上的程序：

1. LX终端（LXTerminal）: Linux命令行终端，打开后会进入Bash环境，可以使用Linux命令
2. Firefox：浏览器
3. sublime/GVim：好用的编辑器
4. git，用于获得参考代码

### 3. 环境使用

使用GVim编辑器输入实验所需的代码及文件，使用LX终端（LXTerminal）运行所需命令进行操作。


## 二、课程介绍

课程目的：

    进一步了解一些控件的使用以及如何布局
    界面和逻辑如何分开
    核心逻辑在小游戏中占多大比重


GUI只是工具，关键是你用GUI来做什么。前面我们学会如何画图形，如何绑定动作。这一节我们用它们来做个有趣的2048游戏。

[2048原版游戏地址](http://gabrielecirulli.github.io/2048)

wxpython版游戏代码可以clone自我的代码仓库。

http://git.shiyanlou.com/heibanke/shiyanlou_cs427


###1. 先定义Frame类

```
class Frame(wx.Frame):

    def __init__(self,title):
        super(Frame,self).__init__(None,-1,title,
                style=wx.DEFAULT_FRAME_STYLE^wx.MAXIMIZE_BOX^wx.RESIZE_BORDER)

        self.colors = {0:(204,192,179),2:(238, 228, 218),4:(237, 224, 200),
                8:(242, 177, 121),16:(245, 149, 99),32:(246, 124, 95),
                64:(246, 94, 59),128:(237, 207, 114),256:(237, 207, 114),
                512:(237, 207, 114),1024:(237, 207, 114),2048:(237, 207, 114),
                4096:(237, 207, 114),8192:(237, 207, 114),16384:(237, 207, 114),
                32768:(237, 207, 114),65536:(237, 207, 114),131072:(237, 207, 114),
                262144:(237, 207, 114),524288:(237, 207, 114),1048576:(237, 207, 114),
                2097152:(237, 207, 114),4194304:(237, 207, 114),
                8388608:(237, 207, 114),16777216:(237, 207, 114),
                33554432:(237, 207, 114),67108864:(237, 207, 114),
                134217728:(237, 207, 114),268435456:(237, 207, 114),
                536870912:(237, 207, 114),1073741824:(237, 207, 114),
                2147483648:(237, 207, 114),4294967296:(237, 207, 114),
                8589934592:(237, 207, 114),17179869184:(237, 207, 114),
                34359738368:(237, 207, 114),68719476736:(237, 207, 114),
                137438953472:(237, 207, 114),274877906944:(237, 207, 114),
                549755813888:(237, 207, 114),1099511627776:(237, 207, 114),
                2199023255552:(237, 207, 114),4398046511104:(237, 207, 114),
                8796093022208:(237, 207, 114),17592186044416:(237, 207, 114),
                35184372088832:(237, 207, 114),70368744177664:(237, 207, 114),
                140737488355328:(237, 207, 114),281474976710656:(237, 207, 114),
                562949953421312:(237, 207, 114),1125899906842624:(237, 207, 114),
                2251799813685248:(237, 207, 114),4503599627370496:(237, 207, 114),
                9007199254740992:(237, 207, 114),18014398509481984:(237, 207, 114),
                36028797018963968:(237, 207, 114),72057594037927936:(237, 207, 114)}
                
        self.setIcon()
        self.initGame()
        self.initBuffer()
        panel = wx.Panel(self)
        panel.Bind(wx.EVT_KEY_DOWN,self.onKeyDown)
        panel.SetFocus()
        
        self.Bind(wx.EVT_SIZE,self.onSize) # use wx.BufferedPaintDC
        self.Bind(wx.EVT_PAINT,self.onPaint)
        self.Bind(wx.EVT_CLOSE,self.onClose)
        self.SetClientSize((505,720))
        self.Center()
        self.Show()
        
    def onClose(self,event):
        self.saveScore()
        self.Destroy()

    def setIcon(self):
        icon = wx.Icon(&#34;icon.ico&#34;,wx.BITMAP_TYPE_ICO)
        self.SetIcon(icon)
        
    def loadScore(self):
        if os.path.exists(&#34;bestscore.ini&#34;):
            ff = open(&#34;bestscore.ini&#34;)
            self.bstScore = int(ff.read())
            ff.close()

    def saveScore(self):
        ff = open(&#34;bestscore.ini&#34;,&#34;w&#34;)
        ff.write(str(self.bstScore))
        ff.close()
    
if __name__ == &#34;__main__&#34;:
    app = wx.App()
    Frame(u&#34;2048 v1.0.1 by heibanke&#34;)
    app.MainLoop()

```

colors是定义2，4，8，不同分数的块颜色不同。三个数值分别是RedGreenBlue。saveScore和loadScore是记录你的最高分，记录到文本文件里。

大部分之前的课程都已经熟悉了。关键在于initGame，initBuffer和绑定的几个方法。我们慢慢看。

###2. initGame

```
def initGame(self):
    self.bgFont = wx.Font(50,wx.SWISS,wx.NORMAL,wx.BOLD,face=u&#34;Roboto&#34;)
    self.scFont = wx.Font(36,wx.SWISS,wx.NORMAL,wx.BOLD,face=u&#34;Roboto&#34;)
    self.smFont = wx.Font(12,wx.SWISS,wx.NORMAL,wx.NORMAL,face=u&#34;Roboto&#34;)
    self.curScore = 0
    self.bstScore = 0
    self.loadScore()
    self.data = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]
    count = 0
    while count&lt;2:
        row = random.randint(0,len(self.data)-1)
        col = random.randint(0,len(self.data[0])-1)
        if self.data[row][col]!=0: 
            continue           
        self.data[row][col] = 2 if random.randint(0,1) else 4
        count += 1
```

这里初始化各种字体，curScore为当前分数。bstScore为最高分数。data为4×4的棋盘。然后while循环是在4×4棋盘上随机位置产生2个块2或4。

###3. initBuffer

```
def initBuffer(self):
    w,h = self.GetClientSize()
    self.buffer = wx.EmptyBitmap(w,h)
    
def onSize(self,event):
    self.initBuffer()
    self.drawAll()
```

initBuffer定义一块buffer，用来使用BufferedDC来画图。
onSize是在窗口改变时重新initBuffer，并调用drawAll来画界面。

所以界面的关键在drawAll，用户的动作响应在onKeyDown。这两个是该程序的重点。



###4. drawAll

```
def drawAll(self):
    dc = wx.BufferedDC(wx.ClientDC(self),self.buffer)
    self.drawBg(dc)
    self.drawLogo(dc)
    self.drawLabel(dc)
    self.drawScore(dc)
    self.drawTiles(dc)
    
def drawChange(self,score):
    dc = wx.BufferedDC(wx.ClientDC(self),self.buffer)
    if score:
        self.curScore += score
        if self.curScore &gt; self.bstScore:
            self.bstScore = self.curScore
        self.drawScore(dc)
    self.drawTiles(dc)
```        
drawAll就是把界面逐次画出来，包括背景，logo，Label，Score和棋盘里的块(Tiles)。drawChange是当用户有动作后，把改变的地方重新画一遍，如score和Tiles。

这些大家自己看吧。主要是wxpython控件的用法。之前没讲到的，请查阅wxpython资料。

###5. onKeyDown

```
def onKeyDown(self,event):
    keyCode = event.GetKeyCode()
            
    if keyCode==wx.WXK_UP:
        self.doMove(*self.slideUpDown(True))
    elif keyCode==wx.WXK_DOWN:
        self.doMove(*self.slideUpDown(False))
    elif keyCode==wx.WXK_LEFT:
        self.doMove(*self.slideLeftRight(True))
    elif keyCode==wx.WXK_RIGHT:
        self.doMove(*self.slideLeftRight(False))        
```
这里doMove的参数是slideUpDown或者slideLeftRight方法返回的元组。
\*代表元组，\**代表字典。

当用户按上或下方向时，slideUpDown对棋盘的列进行处理，当用户按左或右方向时，slideLeftRight对棋盘的行进行处理。两者类似，这里仅对slideUpDown进行说明。

```
def slideUpDown(self,up):
    score = 0
    numCols = len(self.data[0])
    numRows = len(self.data)
    oldData = copy.deepcopy(self.data)
    
    for col in range(numCols):
        cvl = [self.data[row][col] for row in range(numRows) if self.data[row][col]!=0]

        if len(cvl)&gt;=2:
            score += self.update(cvl,up)
        for i in range(numRows-len(cvl)):
            if up: cvl.append(0)
            else: cvl.insert(0,0)
        for row in range(numRows): self.data[row][col] = cvl[row]
    return oldData!=self.data,score
    
def update(self,vlist,direct):
    score = 0
    if direct: #up or left
        i = 1
        while i&lt;len(vlist):
            if vlist[i-1]==vlist[i]:
                del vlist[i]
                vlist[i-1] *= 2
                score += vlist[i-1]
                i += 1
            i += 1
    else:
        i = len(vlist)-1
        while i&gt;0:
            if vlist[i-1]==vlist[i]:
                del vlist[i]
                vlist[i-1] *= 2
                score += vlist[i-1]
                i -= 1
            i -= 1      
    return score
```
得到行数列数，备份数据到oldData后，对每列数据进行处理。
棋盘的列从上往下序号是

    0 
    1 --&gt; 2 
    2 
    3 --&gt; 2

如果在1，3有两个Tile值为2的话，点击上，则
```
cvl = [self.data[row][col] for row in range(numRows) if self.data[row][col]!=0]
```
将两个2提取出来到cvl，update函数后，将两个2合并为1个4，并return这一步得到的分数。

```
for i in range(numRows-len(cvl)):
    if up: cvl.append(0)
    else: cvl.insert(0,0)
for row in range(numRows): 
    self.data[row][col] = cvl[row]

```
然后根据按的是up还是down决定是在cvl后面加0，还是在前面加0，补齐为4个。然后逐一替换到data里。
```
return oldData!=self.data,score
```
最后return一个元组，(数据是否变化的标志move，和这一步得到的分数score)。这个元组就是方法doMove的参数。

这是最简单的情况，再考虑三个Tile相同，三个Tile有2个相同等各种情况是否适用，就差不多了。然后再扩展到下方向和左右方向上。

###6. doMove

```
def doMove(self,move,score):
    if move:
        self.putTile()
        self.drawChange(score)
        if self.isGameOver():
            if wx.MessageBox(u&#34;游戏结束，是否重新开始？&#34;,u&#34;哈哈&#34;,
                    wx.YES_NO|wx.ICON_INFORMATION)==wx.YES:
                bstScore = self.bstScore
                self.initGame()
                self.bstScore = bstScore
                self.drawAll()
```
如果移动了，则putTile用来在棋盘上还是0的位置上随机挑一个，生成一个Tile值为2或4。然后把这些变化画出来就调用drawChange(score)。

最后判断是否GameOver，也就是4个方向分别试一下能不能move，有一个方向能move则没有GameOver。
```
def isGameOver(self):
    copyData = copy.deepcopy(self.data)
    
    flag = False
    if not self.slideUpDown(True)[0] and not self.slideUpDown(False)[0] and \
            not self.slideLeftRight(True)[0] and not self.slideLeftRight(False)[0]:
        flag = True
    if not flag: self.data = copyData
    return flag
```

OK了，是不是很简单。其实最容易错的地方就是update和slide。多想想多试试，加些print也可以，总之搞懂它们你就能开发一个属于自己的2048.


## 三. 总结

本节课我们开发了一个2048游戏，你如果觉得还不过瘾。可以尝试给它增加一些功能。比如：

1. 悔棋。有时候一步错步步错，能否有个按键，点一下能反转时间。呵呵。
2. 扩大。棋盘能不能6×6？
3. 智能。自己打不到8192？没关系，开发个人工智能，提示你往哪里走，突破极限别忘了把代码给我发一份。

这些就当作思考题吧。别忘了保存代码，觉得实验不错的，别忘了写篇感想刺激一下后来人。

到此我们的实验课就结束了。如果你觉得这种方式不错，并且对web后端感兴趣的话，欢迎到云课堂&lt;&lt;用Python做些事&gt;&gt;里看看。web后端也在实验楼开发了一门私有实验课程，**用django开发云记账项目**。希望我的课程能够对你有帮助，谢谢支持！

## 帮助

如果对实验操作有疑问可以在实验课提出问答。 