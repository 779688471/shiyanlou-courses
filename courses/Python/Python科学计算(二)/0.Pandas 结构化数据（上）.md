# Pandas 结构化数据（上）

## 一、实验说明

Pandas 是 python 的一个数据分析包，属于PyData项目的一部分。Pandas最初被作为金融数据分析工具而开发出来，因此 pandas 为时间序列分析提供了很好的支持。 Pandas 的名称来自于面板数据（panel data）和python数据分析（data analysis）。panel data是经济学中关于多维数据集的一个术语，在Pandas中也提供了panel的数据类型。

### 1. 环境登录

无需密码自动登录，系统用户名shiyanlou

### 2. 环境介绍

本课程实验环境使用Spyder。首先打开terminal，然后输入以下命令：

    spyder -w scientific-python-lectures   (-w 参数指定工作目录)
    

关于Spyder的使用可参考文档：https://pythonhosted.org/spyder/

本实验基本在控制台下进行，可关闭 spyder 中的其余窗口，只保留控制台。如需要调出窗口，可以通过 view-&gt;windows and toolbar 调出。比如希望在py文件中编写代码，可以 view-&gt;windows and toolbar-&gt;Editor 调出编辑器窗口。

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid8834labid1233timestamp1468334229103.png/wm)

## 二、实验内容

载入需要的包：

    import pandas as pd
    import numpy as np
    import matplotlib.pyplot as plt

## Series

Series 是一个一维类数组对象，包含一列数据与与其关联的一列数据标签，数据标签即为数据的序列。

### 创建一个 Series：

    s = pd.Series([1,3,5,np.nan,6,8])
    s

输出：

    0     1
    1     3
    2     5
    3   NaN
    4     6
    5     8
    dtype: float64

## DataFrame

DataFrame 是一个表格化的数据结构，它同时拥有行序号与列序号。

### 创建一个 DataFrame

通过传递一个 numpy 数组创建 DataFrame
    
    #创建日期索引序列 
    dates = pd.date_range(&#39;20130101&#39;, periods=6)
    #创建Dataframe，其中 index 决定索引序列，columns 决定列名
    df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list(&#39;ABCD&#39;))
    df

输出：

                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988

通过传递一个字典创建 DataFrame

    df2 = pd.DataFrame({ &#39;A&#39; : 1.,
                         &#39;B&#39; : pd.Timestamp(&#39;20130102&#39;),
                         &#39;C&#39; : pd.Series(1,index=list(range(4)),dtype=&#39;float32&#39;),
                         &#39;D&#39; : np.array([3] * 4,dtype=&#39;int32&#39;),
                         &#39;E&#39; : pd.Categorical([&#34;test&#34;,&#34;train&#34;,&#34;test&#34;,&#34;train&#34;]),
                         &#39;F&#39; : &#39;foo&#39; })

输出：

       A          B  C  D      E    F
    0  1 2013-01-02  1  3   test  foo
    1  1 2013-01-02  1  3  train  foo
    2  1 2013-01-02  1  3   test  foo
    3  1 2013-01-02  1  3  train  foo

查询每一列的数据结构

    df2.dtypes

输出：

    A           float64
    B    datetime64[ns]
    C           float32
    D             int32
    E          category
    F            object
    dtype: object

##数据观察

观察开头的数据

    df.head()

输出：

                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401

观察末尾的数据

    df.tail(3)

                       A         B         C         D
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988

显示索引

    df.index

输出：

    DatetimeIndex([&#39;2013-01-01&#39;, &#39;2013-01-02&#39;, &#39;2013-01-03&#39;, &#39;2013-01-04&#39;,
                   &#39;2013-01-05&#39;, &#39;2013-01-06&#39;],
                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;, tz=None)

显示列

    df.columns

输出：
    
    Index([u&#39;A&#39;, u&#39;B&#39;, u&#39;C&#39;, u&#39;D&#39;], dtype=&#39;object&#39;)

显示底层 numpy 结构

    df.values

输出：

    array([[ 0.4691, -0.2829, -1.5091, -1.1356],
           [ 1.2121, -0.1732,  0.1192, -1.0442],
           [-0.8618, -2.1046, -0.4949,  1.0718],
           [ 0.7216, -0.7068, -1.0396,  0.2719],
           [-0.425 ,  0.567 ,  0.2762, -1.0874],
           [-0.6737,  0.1136, -1.4784,  0.525 ]])

DataFrame 的基本统计学属性预览

    df.describe()

输出：

                  A         B         C         D
    count  6.000000  6.000000  6.000000  6.000000       #数量
    mean   0.073711 -0.431125 -0.687758 -0.233103       #平均值
    std    0.843157  0.922818  0.779887  0.973118       #标准差
    min   -0.861849 -2.104569 -1.509059 -1.135632       #最小值
    25%   -0.611510 -0.600794 -1.368714 -1.076610       #正态分布 25%
    50%    0.022070 -0.228039 -0.767252 -0.386188       #正态分布 50%
    75%    0.658444  0.041933 -0.034326  0.461706       #正态分布 75%
    max    1.212112  0.567020  0.276232  1.071804       #最大值

转置

    df.T

输出：

       2013-01-01  2013-01-02  2013-01-03  2013-01-04  2013-01-05  2013-01-06
    A    0.469112    1.212112   -0.861849    0.721555   -0.424972   -0.673690
    B   -0.282863   -0.173215   -2.104569   -0.706771    0.567020    0.113648
    C   -1.509059    0.119209   -0.494929   -1.039575    0.276232   -1.478427
    D   -1.135632   -1.044236    1.071804    0.271860   -1.087401    0.524988

根据某一轴的索引进行排序

    df.sort_index(axis=1, ascending=False)

输出：

                       D         C         B         A
    2013-01-01 -1.135632 -1.509059 -0.282863  0.469112
    2013-01-02 -1.044236  0.119209 -0.173215  1.212112
    2013-01-03  1.071804 -0.494929 -2.104569 -0.861849
    2013-01-04  0.271860 -1.039575 -0.706771  0.721555
    2013-01-05 -1.087401  0.276232  0.567020 -0.424972
    2013-01-06  0.524988 -1.478427  0.113648 -0.673690

根据某一列的数值进行排序

    df.sort(columns=&#39;B&#39;)

输出：

                       A         B         C         D
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401

##选择/切片

选择单独的一列，返回 Serires，与 df.A 效果相当。

    df[&#39;A&#39;]

输出：

    2013-01-01    0.469112
    2013-01-02    1.212112
    2013-01-03   -0.861849
    2013-01-04    0.721555
    2013-01-05   -0.424972
    2013-01-06   -0.673690
    Freq: D, Name: A, dtype: float64

位置切片

    df[0:3]

输出：

                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804

索引切片

    df[&#39;20130102&#39;:&#39;20130104&#39;]

输出：

                       A         B         C         D
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860


### 通过标签选择


    df.loc[dates[0]]
输出： 

    A    0.469112
    B   -0.282863
    C   -1.509059
    D   -1.135632
    Name: 2013-01-01 00:00:00, dtype: float64

对多个轴同时通过标签进行选择

    df.loc[:,[&#39;A&#39;,&#39;B&#39;]]

输出： 

                       A         B
    2013-01-01  0.469112 -0.282863
    2013-01-02  1.212112 -0.173215
    2013-01-03 -0.861849 -2.104569
    2013-01-04  0.721555 -0.706771
    2013-01-05 -0.424972  0.567020
    2013-01-06 -0.673690  0.113648


获得某一个单元的数据

    df.loc[dates[0],&#39;A&#39;]
    0.46911229990718628

速度更快的做法

    df.at[dates[0],&#39;A&#39;]
    0.46911229990718628

### 通过位置进行选择

    df.iloc[3]

输出：

    A    0.721555
    B   -0.706771
    C   -1.039575
    D    0.271860
    Name: 2013-01-04 00:00:00, dtype: float64

切片
   
    df.iloc[3:5,0:2]

输出：

                       A         B
    2013-01-04  0.721555 -0.706771
    2013-01-05 -0.424972  0.567020

列表选择

    df.iloc[[1,2,4],[0,2]]
 
输出：

                       A         C
    2013-01-02  1.212112  0.119209
    2013-01-03 -0.861849 -0.494929
    2013-01-05 -0.424972  0.276232

获得某一个单元的数据

    df.iloc[1,1]
    
输出：

    -0.17321464905330858

更快的做法：

    df.iat[1,1]

输出：

    -0.17321464905330858

### 布尔索引

根据某一列的数据达成条件进行索引

    df[df.A &gt; 0]

输出：

                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860

获得大于零的项的数值

    df[df &gt; 0]

输出： 

                       A         B         C         D
    2013-01-01  0.469112       NaN       NaN       NaN
    2013-01-02  1.212112       NaN  0.119209       NaN
    2013-01-03       NaN       NaN       NaN  1.071804
    2013-01-04  0.721555       NaN       NaN  0.271860
    2013-01-05       NaN  0.567020  0.276232       NaN
    2013-01-06       NaN  0.113648       NaN  0.524988

使用 ``isin()`` 方法进行过滤

    df2 = df.copy()
    df2[&#39;E&#39;] = [&#39;one&#39;, &#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;,&#39;three&#39;]
    df2

输出：

                       A         B         C         D      E
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three

    df2[df2[&#39;E&#39;].isin([&#39;two&#39;,&#39;four&#39;])]

输出：

                       A         B         C         D     E
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four

## 赋值

新增一列，根据索引排列

    s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range(&#39;20130102&#39;, periods=6))
    s1

输出：

    2013-01-02    1
    2013-01-03    2
    2013-01-04    3
    2013-01-05    4
    2013-01-06    5
    2013-01-07    6
    Freq: D, dtype: int64

输入：

    df[&#39;F&#39;] = s1
    df.at[dates[0],&#39;A&#39;] = 0
    df.iat[0,1] = 0
    df.loc[:,&#39;D&#39;] = np.array([5] * len(df))
    df

输出：

                       A         B         C  D   F
    2013-01-01  0.000000  0.000000 -1.509059  5 NaN
    2013-01-02  1.212112 -0.173215  0.119209  5   1
    2013-01-03 -0.861849 -2.104569 -0.494929  5   2
    2013-01-04  0.721555 -0.706771 -1.039575  5   3
    2013-01-05 -0.424972  0.567020  0.276232  5   4
    2013-01-06 -0.673690  0.113648 -1.478427  5   5

根据条件进行赋值

    df2 = df.copy()
    df2[df2 &gt; 0] = -df2
    df2

输出：

                       A         B         C  D   F
    2013-01-01  0.000000  0.000000 -1.509059 -5 NaN
    2013-01-02 -1.212112 -0.173215 -0.119209 -5  -1
    2013-01-03 -0.861849 -2.104569 -0.494929 -5  -2
    2013-01-04 -0.721555 -0.706771 -1.039575 -5  -3
    2013-01-05 -0.424972 -0.567020 -0.276232 -5  -4
    2013-01-06 -0.673690 -0.113648 -1.478427 -5  -5

##缺省项

在 pandas 中使用 ``np.nan`` 作为缺省项的值。

    df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + [&#39;E&#39;])
    df1.loc[dates[0]:dates[1],&#39;E&#39;] = 1
    df1

输出：

                       A         B         C  D   F   E
    2013-01-01  0.000000  0.000000 -1.509059  5 NaN   1
    2013-01-02  1.212112 -0.173215  0.119209  5   1   1
    2013-01-03 -0.861849 -2.104569 -0.494929  5   2 NaN
    2013-01-04  0.721555 -0.706771 -1.039575  5   3 NaN

删除所有带有缺省项的行

    df1.dropna(how=&#39;any&#39;)

输出：

                       A         B         C  D  F  E
    2013-01-02  1.212112 -0.173215  0.119209  5  1  1

填充缺省项

    df1.fillna(value=5)

输出：

                       A         B         C  D  F  E
    2013-01-01  0.000000  0.000000 -1.509059  5  5  1
    2013-01-02  1.212112 -0.173215  0.119209  5  1  1
    2013-01-03 -0.861849 -2.104569 -0.494929  5  2  5
    2013-01-04  0.721555 -0.706771 -1.039575  5  3  5

获得缺省项的布尔掩码：

    pd.isnull(df1)

输出：

                    A      B      C      D      F      E
    2013-01-01  False  False  False  False   True  False
    2013-01-02  False  False  False  False  False  False
    2013-01-03  False  False  False  False  False   True
    2013-01-04  False  False  False  False  False   True
