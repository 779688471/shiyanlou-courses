# 第 5 章　高级数据管理

## 一、实验介绍

### 1.1 实验内容

在第 4 章，我们审视了 R 中基本的数据集处理方法，本章我们将关注一些高级话题。本章分为三个基本部分。在第一部分中，我们将快速浏览 R 中的多种数学、统计和字符处理函数。为了让这一部分的内容相互关联，我们先引入一个能够使用这些函数解决的数据处理问题。在讲解过这些函数以后，再为这个数据处理问题提供一个可能的解决方案。

接下来，我们将讲解如何自己编写函数来完成数据处理和分析任务。首先，我们将探索控制程序流程的多种方式，包括循环和条件执行语句。然后，我们将研究用户自编函数的结构，以及在编写完成后如何调用它们。

最后，我们将了解数据的整合和概述方法，以及数据集的重塑和重构方法。在整合数据时，你可以使用任何内建或自编函数来获取数据的概述，所以你在本章前两部分中学习的内容将会派上用场。

### 1.2 课程来源

本课程基于 [图灵社区](http://www.ituring.com.cn/) 的 [《 R 语言实战（第 2 版）》](http://www.ituring.com.cn/book/1699) 第 5 章制作，感谢 [图灵社区](http://www.ituring.com.cn/) 授权实验楼发布。如需系统的学习本书，请购买[《 R 语言实战（第 2 版）》](http://www.ituring.com.cn/book/1699)。

为了保证可以在实验楼环境中完成本次实验，我们在原书内容基础上补充了一系列的实验指导，比如实验截图，代码注释，帮助您更好得实战。

如果您对于实验有疑惑或者建议可以随时在讨论区中提问，与同学们一起探讨。

### 1.3 实验知识点

- 数学和统计函数
- 字符处理函数
- 循环和条件执行
- 自编函数
- 数据整合与重塑

### 1.4 实验环境

- R version 3.4.1
- Xfce 终端

### 1.5 适合人群

本课程难度为简单，属于初级级别课程，对于没有 R 语言基础的同学也很友好。

## 二、实验内容

### 一个数据处理难题

要讨论数值和字符处理函数，让我们首先考虑一个数据处理问题。一组学生参加了数学、科学和英语考试。为了给所有学生确定一个单一的成绩衡量指标，需要将这些科目的成绩组合起来。另外，你还想将前 20% 的学生评定为 A，接下来 20% 的学生评定为 B，依次类推。最后，你希望按字母顺序对学生排序。数据如表 2-1 所示。

**表 2-1　学生成绩数据**

| 学生姓名              | 数学   | 科学   | 英语   |
| ----------------- | ---- | ---- | ---- |
| John Davis        | 502  | 95   | 25   |
| Angela Williams   | 600  | 99   | 22   |
| Bullwinkle Moose  | 412  | 80   | 18   |
| David Jones       | 358  | 82   | 15   |
| Janice Markhammer | 495  | 75   | 20   |
| Cheryl Cushing    | 512  | 85   | 28   |
| Reuven Ytzrhak    | 410  | 80   | 15   |
| Greg Knox         | 625  | 95   | 30   |
| Joel England      | 573  | 89   | 27   |
| Mary Rayburn      | 522  | 86   | 18   |

观察此数据集，马上可以发现一些明显的障碍。首先，三科考试的成绩是无法比较的。由于它们的均值和标准差相去甚远，所以对它们求平均值是没有意义的。你在组合这些考试成绩之前，必须将其变换为可比较的单元。其次，为了评定等级，你需要一种方法来确定某个学生在前述得分上百分比排名。再次，表示姓名的字段只有一个，这让排序任务复杂化了。为了正确地将其排序，需要将姓和名拆开。

以上每一个任务都可以巧妙地利用 R 中的数值和字符处理函数完成。在讲解完下一节中的各种函数之后，我们将考虑一套可行的解决方案，以解决这项数据处理难题。

## 三、实验步骤

首先需要进入 R 的环境：

```
    sudo R

```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3175timestamp1499324672024.png/wm)

### 3.1 数值和字符处理函数

本节我们将综述 R 中作为数据处理基石的函数，它们可分为数值（数学、统计、概率）函数和字符处理函数。在阐述过每一类函数以后，我将为你展示如何将函数应用到矩阵和数据框的列（变量）和行（观测）上。

### 3.1.1 数学函数

表 3-2 列出了常用的数学函数和简短的用例。

| 函数                                       | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| `abs(x)`                                 | 绝对值`abs(-4)`返回值为 4                       |
| `sqrt(x)`                                | 平方根`sqrt(25)`返回值为 5，和 2`5^(0.5)`等价       |
| `ceiling(x)`                             | 不小于*x*的最小整数`ceiling(3.475)`返回值为 4        |
| `floor(x)`                               | 不大于*x*的最大整数`floor(3.475)`返回值为 3          |
| `trunc(*x*)`                             | 向 0 的方向截取的*x*中的整数部分`trunc(5.99)`返回值为 5   |
| `round(*x*, digits=*n*)`                 | 将*x*舍入为指定位的小数`round(3.475, digits=2)`返回值为 3.48 |
| `signif(*x*, digits=*n*)`                | 将*x*舍入为指定的有效数字位数`signif(3.475, digits=2)`返回值为 3.5 |
| `cos(*x*)`、`sin(*x*)`、`tan(*x*)`         | 余弦、正弦和正切`cos(2)`返回值为 - 0.416             |
| `acos(*x*)`、`asin(*x*)`、`atan(*x*)`      | 反余弦、反正弦和反正切`acos(-0.416)`返回值为 2          |
| `cosh(*x*)`、`sinh(*x*)`、`tanh(*x*)`      | 双曲余弦、双曲正弦和双曲正切`sinh(2)`返回值为 3.627        |
| `acosh(*x*)`、`asinh(*x*)`、`atanh(*x*)`   | 反双曲余弦、反双曲正弦和反双曲正切`asinh(3.627)`返回值为 2    |
| `log(*x*,base=*n*)``log(*x*)``log10(*x*)` | 对*x*取以*n*为底的对数为了方便起见：• `log(*x*)`为自然对数• `log10(*x*)`为常用对数• `log(10)`返回值为 2.3026• `log10(10)`返回值为 1 |
| `exp(*x*)`                               | 指数函数`exp(2.3026)`返回值为 10                 |

对数据做变换是这些函数的一个主要用途。例如，你经常会在进一步分析之前将收入这种存在明显偏倚的变量取对数。数学函数也被用作公式中的一部分，用于绘图函数（例如`x`对`sin(x)`）和在输出结果之前对数值做格式化。

表 3-2 中的示例将数学函数应用到了标量（单独的数值）上。当这些函数被应用于数值向量、矩阵或数据框时，它们会作用于每一个独立的值。例如，`sqrt(c(4, 16, 25))`的返回值为`c(2, 4, 5)`。

### 3.1.2 统计函数

常用的统计函数如表 3-3 所示，其中许多函数都拥有可以影响输出结果的可选参数。举例来说：

```
y <- mean(x)


```

提供了对象 x 中元素的算术平均数，而：

```
z <- mean(x, trim = 0.05, na.rm=TRUE)


```

则提供了截尾平均数，即丢弃了最大 5% 和最小 5% 的数据和所有缺失值后的算术平均数。请使用`help()`了解以上每个函数和其参数的用法。

**表 3-3　统计函数**

| 函数                                   | 描述                                       |
| ------------------------------------ | ---------------------------------------- |
| `mean(*x*)`                          | 平均数`mean(c(1,2,3,4))`返回值为 2.5            |
| `median(*x*)`                        | 中位数`median(c(1,2,3,4))`返回值为 2.5          |
| `sd(*x*)`                            | 标准差`sd(c(1,2,3,4))`返回值为 1.29             |
| `var(*x*)`                           | 方差`var(c(1,2,3,4))`返回值为 1.67             |
| `mad(*x*)`                           | 绝对中位差（median absolute deviation）`mad(c(1,2,3,4))`返回值为 1.48 |
| `quantile(*x*,probs)`                | 求分位数。其中*x*为待求分位数的数值型向量，`probs`为一个由 [0,1] 之间的概率值组成的数值向量# 求`x`的`30%`和`84%`分位点`y <- quantile(x, c(.3,.84))` |
| `range(*x*)`                         | 求值域`x <- c(1,2,3,4)``range(x)`返回值为`c(1,4)``diff(range(x))`返回值为 3 |
| `sum(*x*)`                           | 求和`sum(c(1,2,3,4))`返回值为 10               |
| `diff(*x*, lag=*n*)`                 | 滞后差分，`lag`用以指定滞后几项。默认的`lag`值为 1`x<- c(1, 5, 23, 29)``diff(*x*)`返回值为`c(4, 18, 6)` |
| `min(*x*)`                           | 求最小值`min(c(1,2,3,4))`返回值为 1              |
| `max(*x*)`                           | 求最大值`max(c(1,2,3,4))`返回值为 4              |
| `scale(*x*,center=TRUE, scale=TRUE)` | 为数据对象*x*按列进行中心化`(center=TRUE)`或标准化`(center=TRUE,scale=TRUE)`；代码清单 3-6 中给出了一个示例 |

要了解这些函数的实战应用，请参考代码清单 3-1。这个例子演示了计算某个数值向量的均值和标准差的两种方式。

> **代码清单 3-1**　均值和标准差的计算

```
> x <- c(1,2,3,4,5,6,7,8)

> mean(x)         （以下4行）简洁的方式
[1] 4.5                    
> sd(x)                    
[1] 2.449490               

> n <- length(x)            （以下8行）冗长的方式
> meanx <- sum(x)/n            
> css <- sum((x - meanx)^2)    
> sdx <- sqrt(css / (n-1))     
> meanx                        
[1] 4.5                        
> sdx                          
[1] 2.449490                   

```

第二种方式中修正平方和（css）的计算过程是很有启发性的：

(1) `x`等于`c(1, 2, 3, 4, 5, 6, 7, 8)`，`x`的平均值等于 4.5（`length(x)`返回了`x`中元素的数量）；

(2) `(x - meanx)`从`x`的每个元素中减去了 4.5，结果为`c(-3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5)`；

(3) `(x - meanx)^2`将`(x - meanx)`的每个元素求平方，结果为`c(12.25, 6.25, 2.25, 0.25, 0.25, 2.25, 6.25, 12.25)`；

(4) `sum((x - meanx)^2)`对`(x - meanx)^2)`的所有元素求和，结果为 42。

R 中公式的写法和类似 MATLAB 的矩阵运算语言有着许多共同之处。（我们将在附录 D 中具体关注解决矩阵代数问题的方法。）

> **数据的标准化**

默认情况下，函数`scale()`对矩阵或数据框的指定列进行均值为 0、标准差为 1 的标准化：

> ```
> newdata <- scale(mydata)
>
>
>
> ```

要对每一列进行任意均值和标准差的标准化，可以使用如下的代码：

> ```
> newdata <- scale(mydata)*SD + M
>
>
>
> ```

其中的*M*是想要的均值，*SD*为想要的标准差。在非数值型的列上使用`scale()`函数将会报错。要对指定列而不是整个矩阵或数据框进行标准化，你可以使用这样的代码：

> ```
> newdata <- transform(mydata, myvar = scale(myvar)*10+50)
>
>
>
> ```
>
> 此句将变量`myvar`标准化为均值 50、标准差为 10 的变量。

### **3.1.3　概率函数**

你可能在疑惑为何概率函数未和统计函数列在一起。（你真的对此有些困惑，对吧？）虽然根据定义，概率函数也属于统计类，但是它们非常独特，应独立设一节进行讲解。概率函数通常用来生成特征已知的模拟数据，以及在用户编写的统计函数中计算概率值。

在 R 中，概率函数形如 ：

```
[dpqr]distribution_abbreviation()



```

其中第一个字母表示其所指**分布**的某一方面：

`d =` 密度函数（density）

`p =` 分布函数（distribution function）

`q =` 分位数函数（quantile function）

`r =` 生成随机数（随机偏差）

常用的概率函数列于表 3-4 中。

**表 3-4　概率分布**

| 分布名称           | 缩写         |
| -------------- | ---------- |
| Beta 分布        | `beta`     |
| 二项分布           | `binom`    |
| 柯西分布           | `cauchy`   |
| （非中心）卡方分布      | `chisq`    |
| 指数分布           | `exp`      |
| F 分布           | `f`        |
| Gamma 分布       | `gamma`    |
| 几何分布           | `geom`     |
| 超几何分布          | `hyper`    |
| 对数正态分布         | `lnorm`    |
| Logistic 分布    | `logis`    |
| 多项分布           | `multinom` |
| 负二项分布          | `nbinom`   |
| 正态分布           | `norm`     |
| 泊松分布           | `pois`     |
| Wilcoxon 符号秩分布 | `signrank` |
| t 分布           | `t`        |
| 均匀分布           | `unif`     |
| Weibull 分布     | `weibull`  |
| Wilcoxon 秩和分布  | `wilcox`   |

我们不妨先看看正态分布的有关函数，以了解这些函数的使用方法。如果不指定一个均值和一个标准差，则函数将假定其为标准正态分布（均值为 0，标准差为 1 ）。密度函数（`dnorm`）、分布函数（`pnorm`）、分位数函数（`qnorm`）和随机数生成函数（`rnorm`）的使用示例见表 3-5。

**表 3-5　正态分布函数**

| 问题                                       | 解法                                       |
| ---------------------------------------- | ---------------------------------------- |
| 在区间 [-3, 3] 上绘制标准正态曲线![{75%}](http://www.ituring.com.cn/figures/2016/R2/11.d05z.001.png) | `x <- pretty(c(-3,3), 30)y <- dnorm(x)plot(x, y,  type = "l",  xlab = "Normal Deviate",  ylab = "Density",  yaxs = "i")` |
| 位于* z*=1.96 左侧的标准正态曲线下方面积是多少？            | `pnorm(1.96)`等于 0.975                    |
| 均值为 500，标准差为 100 的正态分布的 0.9 分位点值为多少？     | `qnorm(.9, mean=500, sd=100)`等于 628.16   |
| 生成 50 个均值为 50，标准差为 10 的正态随机数             | `rnorm(50, mean=50, sd=10)`              |

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499074306325.png/wm)

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499074340156.png/wm)

如果读者对`plot()`函数的选项不熟悉，请不要担心。这些选项在第 11 章中有详述。`pretty()`在本章稍后的表 3-7 中进行了解释。

**1. 设定随机数种子**

在每次生成伪随机数的时候，函数都会使用一个不同的种子，因此也会产生不同的结果。你可以通过函数`set.seed()`显式指定这个种子，让结果可以重现（reproducible）。代码清单 3-2 给出了一个示例。这里的函数`runif()`用来生成 0 到 1 区间上服从均匀分布的伪随机数。

> **代码清单 3-2**　生成服从正态分布的伪随机数

```
> runif(5)
[1] 0.8725344 0.3962501 0.6826534 0.3667821 0.9255909
> runif(5)
[1] 0.4273903 0.2641101 0.3550058 0.3233044 0.6584988
> set.seed(1234)
> runif(5)
[1] 0.1137034 0.6222994 0.6092747 0.6233794 0.8609154
> set.seed(1234)
> runif(5)
[1] 0.1137034 0.6222994 0.6092747 0.6233794 0.8609154

```

通过手动设定种子，就可以重现你的结果了。这种能力有助于我们创建会在未来取用的，以及可与他人分享的示例。

**2. 生成多元正态数据**

在模拟研究和蒙特卡洛方法中，你经常需要获取来自给定均值向量和协方差阵的多元正态分布的数据。`MASS`包中的`mvrnorm()`函数可以让这个问题变得很容易。其调用格式为：

```
mvrnorm(n, mean, sigma)



```

其中*n*是你想要的样本大小，*mean*为均值向量，而*sigma*是方差 - 协方差矩阵（或相关矩阵）。代码清单 3-3 从一个参数如下所示的三元正态分布中抽取 500 个观测。

| 均值向量 | `230.7`                  | `146.7`                 | `3.6`               |
| ---- | ------------------------ | ----------------------- | ------------------- |
| 协方差阵 | `15360.8``6721.2``-47.1` | `6721.2``4700.9``-16.5` | `-47.1``-16.5``0.3` |

> **代码清单 3-3**　生成服从多元正态分布的数据

```
> library(MASS)
> options(digits=3)
> set.seed(1234)         <-----❶设定随机数种子

> mean <- c(230.7, 146.7, 3.6)
> sigma <- matrix(c(15360.8, 6721.2, -47.1,       （以下3行）❷指定均值向量、协方差阵
                     6721.2, 4700.9, -16.5,                  
                     -47.1,   -16.5,   0.3), nrow=3, ncol=3)  
> mydata <- mvrnorm(500, mean, sigma)   （以下3行）❸生成数据
> mydata <- as.data.frame(mydata)      
> names(mydata) <- c("y","x1","x2")     

> dim(mydata)           （以下3行）❹查看结果
[1] 500 3                           
> head(mydata, n=10)       
       y    x1   x2
1   98.8  41.3 4.35
2  244.5 205.2 3.57
3  375.7 186.7 3.69
4  -59.2  11.2 4.23
5  313.0 111.0 2.91
6  288.8 185.1 4.18
7  134.8 165.0 3.68
8  171.7  97.4 3.81
9  167.3 101.0 4.01
10 121.1  94.5 3.76

```

代码清单 3-3 中设定了一个随机数种子，这样就可以在之后重现结果❶。你指定了想要的均值向量和方差 - 协方差阵❷，并生成了 500 个伪随机观测❸。为了方便，结果从矩阵转换为数据框，并为变量指定了名称。最后，你确认了拥有 500 个观测和 3 个变量，并输出了前 10 个观测❹。请注意，由于相关矩阵同时也是协方差阵，所以其实可以直接指定相关关系的结构。

R 中的概率函数允许生成模拟数据，这些数据是从服从已知特征的概率分布中抽样而得的。近年来，依赖于模拟数据的统计方法呈指数级增长，在后续各章中会有若干示例。

### **3.1.4　字符处理函数**

数学和统计函数是用来处理数值型数据的，而字符处理函数可以从文本型数据中抽取信息，或者为打印输出和生成报告重设文本的格式。举例来说，你可能希望将某人的姓和名连接在一起，并保证姓和名的首字母大写，抑或想统计可自由回答的调查反馈信息中含有秽语的实例（instance）数量。一些最有用的字符处理函数见表 3-6。

**表 3-6　字符处理函数**

| 函数                                       | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| `nchar(*x*)`                             | 计算*x*中的字符数量`x <- c("ab", "cde", "fghij")``length(x)`返回值为 3 （参见表 3-7）`nchar(x[3])`返回值为 5 |
| `substr(*x*, *start*, *stop*)`           | 提取或替换一个字符向量中的子串`x <- "abcdef"``substr(x, 2, 4)`返回值为`"bcd"``substr(x, 2, 4) <- "22222"`（`x`将变成`"a222ef"`） |
| `grep(*pattern*, *x*, ignore. case=FALSE, fixed=FALSE)` | 在*x*中搜索某种模式。若`fixed=FALSE`，则*pattern*为一个正则表达式。若`fixed=TRUE`，则*pattern*为一个文本字符串。返回值为匹配的下标`grep("A",c("b","A","c"),fixed=TRUE)`返回值为 2 |
| `sub(*pattern*, *replacement*, *x*, ignore.case=FALSE, fixed=FALSE)` | 在*x*中搜索*pattern*，并以文本*replacement*将其替换。若`fixed=FALSE`，则*pattern*为一个正则表达式。若`fixed=TRUE`，则*pattern*为一个文本字符串。`sub("\\s",".","Hello There")`返回值为`Hello.There`。注意，`"\s"`是一个用来查找空白的正则表达式；使用`"\\s"`而不用`"\"`的原因是，后者是 R 中的转义字符（参见 1.3.3 节） |
| `strsplit(*x*, *split*, fixed=FALSE)`    | 在*split*处分割字符向量*x*中的元素。若`fixed=FALSE`，则*pattern*为一个正则表达式。若`fixed=TRUE`，则*pattern*为一个文本字符串`y <- strsplit("abc", "")`将返回一个含有 1 个成分、3 个元素的列表，包含的内容为`"a" "b" "c"``unlist(y)[2]`和`sapply(y, "[", 2)`均会返回`"b"` |
| `paste(…, sep="")`                       | 连接字符串，分隔符为`sep``paste("x", 1:3,sep="")`返回值为`c("x1", "x2", "x3")``paste("x",1:3,sep="M")`返回值为 c`("xM1","xM2" "xM3")``paste("Today is", date())`返回值为`Today is Thu Jun 25 14:17:32 2011`（我修改了日期以让它看起来更接近当前的时间） |
| `toupper(*x*)`                           | 大写转换`toupper("abc")`返回值为`"ABC"`          |
| `tolower(*x*)`                           | 小写转换`tolower("ABC")`返回值为`"abc"`          |

请注意，函数`grep()`、`sub()`和`strsplit()`能够搜索某个文本字符串（`fixed=TRUE`）或某个正则表达式（`fixed=FALSE`，默认值为`FALSE`）。正则表达式为文本模式的匹配提供了一套清晰而简练的语法。例如，正则表达式：

```
^[hc]?at



```

可匹配任意以 0 个或 1 个`h`或`c`开头、后接`at`的字符串。因此，此表达式可以匹配 hat、cat 和 at，但不会匹配 bat。要了解更多，请参考维基百科的 regular expression（**正则表达式**）条目。

### **3.1.5　将函数应用于矩阵和数据框**

R 函数的诸多有趣特性之一，就是它们可以应用到一系列的数据对象上，包括标量、向量、矩阵、数组和数据框。代码清单 3-4 提供了一个示例。

> **代码清单 3-4**　将函数应用于数据对象

```
> a <- 5
> sqrt(a)
[1] 2.236068
> b <- c(1.243, 5.654, 2.99)
> round(b)
[1] 1 6 3
> c <- matrix(runif(12), nrow=3)
> c
       [,1]  [,2]  [,3]  [,4]
[1,] 0.4205 0.355 0.699 0.323
[2,] 0.0270 0.601 0.181 0.926
[3,] 0.6682 0.319 0.599 0.215
> log(c)
       [,1]   [,2]   [,3]   [,4]
[1,] -0.866 -1.036 -0.358 -1.130
[2,] -3.614 -0.508 -1.711 -0.077
[3,] -0.403 -1.144 -0.513 -1.538
> mean(c)
[1] 0.444

```

请注意，在代码清单 3-4 中对矩阵`c`求均值的结果为一个标量（0.444）。函数`mean()`求得的是矩阵中全部 12 个元素的均值。但如果希望求的是各行的均值或各列的均值呢？

R 中提供了一个`apply()`函数，可将一个任意函数 “应用” 到矩阵、数组、数据框的任何维度上。`apply()`函数的使用格式为：

```
apply(x, MARGIN, FUN, ...)



```

其中，*x*为数据对象，*MARGIN*是维度的下标，*FUN*是由你指定的函数，而`...`则包括了任何想传递给*FUN*的参数。在矩阵或数据框中，`MARGIN=1`表示行，`MARGIN=2`表示列。请看以下例子。

> **代码清单 3-5**　将一个函数应用到矩阵的所有行（列）

```
 > mydata <- matrix(rnorm(30), nrow=6)           <----❶生成数据
> mydata
         [,1]   [,2]    [,3]   [,4]   [,5]
[1,]  0.71298  1.368 -0.8320 -1.234 -0.790
[2,] -0.15096 -1.149 -1.0001 -0.725  0.506
[3,] -1.77770  0.519 -0.6675  0.721 -1.350
[4,] -0.00132 -0.308  0.9117 -1.391  1.558
[5,] -0.00543  0.378 -0.0906 -1.485 -0.350
[6,] -0.52178 -0.539 -1.7347  2.050  1.569
> apply(mydata, 1, mean)                        <----❷计算每行的均值
[1] -0.155 -0.504 -0.511  0.154 -0.310  0.165
> apply(mydata, 2, mean)                       <----❸计算每列的均值
[1] -0.2907  0.0449 -0.5688 -0.3442  0.1906
> apply(mydata, 2, mean, trim=0.2)                 <----❹计算每列的截尾均值
[1] -0.1699  0.0127 -0.6475 -0.6575  0.2312

```

首先生成了一个包含正态随机数的 6×5 矩阵❶。然后你计算了 6 行的均值❷，以及 5 列的均值❸。最后，你计算了每列的截尾均值（在本例中，截尾均值基于中间 60% 的数据，最高和最低 20% 的值均被忽略）❹。

所以`apply()`是一种很强大的机制，可把函数应用到数组的某个维度上，而`lapply()`和`sapply()`则可将函数应用到列表（list）上。你将在下一节中看到`sapply()`（它是`lapply()`的更好用的版本）的一个示例。

你已经拥有了解决 2.1 节中数据处理问题所需的所有工具，现在，让我们小试身手。

## **3.2　数据处理难题的一套解决方案**

2.1 节中提出的问题是：将学生的各科考试成绩组合为单一的成绩衡量指标，基于相对名次（前 20%、下 20%、等等）给出从 A 到 F 的评分，根据学生姓氏和名字的首字母对花名册进行排序。我们给出了一种解决方案。

逐步分解如下：

**步骤 1**　原始的学生花名册已经给出了。`options(digits=2)`限定了输出小数点后数字的位数，并且让输出更容易阅读：

```
> options(digits=2)
> Student <- c("John Davis", "Angela Williams", "Bullwinkle Moose",
               "David Jones", "Janice Markhammer", "Cheryl Cushing",
               "Reuven Ytzrhak", "Greg Knox", "Joel England",
               "Mary Rayburn")

> Math <- c(502, 600, 412, 358, 495, 512, 410, 625, 573, 522)
> Science <- c(95, 99, 80, 82, 75, 85, 80, 95, 89, 86)
> English <- c(25, 22, 18, 15, 20, 28, 15, 30, 27, 18)
> roster <- data.frame(Student, Math, Science, English,
                      stringsAsFactors=FALSE)
> roster
             Student  Math Science  English
1         John Davis   502    95      25
2    Angela Williams   600    99      22
3   Bullwinkle Moose   412    80      18
4        David Jones   358    82      15
5  Janice Markhammer   495    75      20
6     Cheryl Cushing   512    85      28
7     Reuven Ytzrhak   410    80      15
8          Greg Knox   625    95      30
9       Joel England   573    89      27
10      Mary Rayburn   522    86      18

```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499074789730.png/wm)

**步骤 2**　由于数学、科学和英语考试的分值不同（均值和标准差相去甚远），在组合之前需要先让它们变得可以比较。一种方法是将变量进行标准化，这样每科考试的成绩就都是用单位标准差来表示，而不是以原始的尺度来表示了。这个过程可以使用`scale()`函数来实现：

```
> z <- scale(roster[,2:4])
> z
        Math  Science  English
 [1,]  0.013   1.078    0.587
 [2,]  1.143   1.591    0.037
 [3,] -1.026  -0.847   -0.697
 [4,] -1.649  -0.590   -1.247
 [5,] -0.068  -1.489   -0.330
 [6,]  0.128  -0.205    1.137
 [7,] -1.049  -0.847   -1.247
 [8,]  1.432   1.078    1.504
 [9,]  0.832   0.308    0.954
[10,]  0.243  -0.077   -0.697

```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499075001552.png/wm)

**步骤 3**　然后，可以通过函数`mean()`来计算各行的均值以获得综合得分，并使用函数`cbind()`将其添加到花名册中：

```
> score <- apply(z, 1, mean)
> roster <- cbind(roster, score)
> roster
             Student   Math  Science   English   score
1         John Davis   502     95        25      0.559
2    Angela Williams   600     99        22      0.924
3   Bullwinkle Moose   412     80        18     -0.857
4        David Jones   358     82        15     -1.162
5  Janice Markhammer   495     75        20     -0.629
6     Cheryl Cushing   512     85        28      0.353
7     Reuven Ytzrhak   410     80        15     -1.048
8          Greg Knox   625     95        30      1.338
9       Joel England   573     89        27      0.698
10      Mary Rayburn   522     86        18     -0.177

```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499075023349.png/wm)

**步骤 4**　函数`quantile()`给出了学生综合得分的百分位数。可以看到，成绩为 A 的分界点为 0.74，B 的分界点为 0.44，等等。

```
> y <- quantile(roster$score, c(.8,.6,.4,.2))
> y
  80%   60%   40%   20%
 0.74  0.44 -0.36 -0.89

```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499075047704.png/wm)

**步骤 5**　通过使用逻辑运算符，你可以将学生的百分位数排名重编码为一个新的类别型成绩变量。下面在数据框`roster`中创建了变量`grade`。

```
> roster$grade[score >= y[1]] <- "A"
> roster$grade[score < y[1] & score >= y[2]] <- "B"
> roster$grade[score < y[2] & score >= y[3]] <- "C"
> roster$grade[score < y[3] & score >= y[4]] <- "D"
> roster$grade[score < y[4]] <- "F"
> roster
             Student   Math  Science   English   score   grade
1         John Davis   502     95        25      0.559     B
2    Angela Williams   600     99        22      0.924     A
3   Bullwinkle Moose   412     80        18     -0.857     D
4        David Jones   358     82        15     -1.162     F
5  Janice Markhammer   495     75        20     -0.629     D
6     Cheryl Cushing   512     85        28      0.353     C
7     Reuven Ytzrhak   410     80        15     -1.048     F
8          Greg Knox   625     95        30      1.338     A
9       Joel England   573     89        27      0.698     B
10      Mary Rayburn   522     86        18     -0.177     C

```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499075056560.png/wm)

**步骤 6**　你将使用函数`strsplit()`以空格为界把学生姓名拆分为姓氏和名字。把`strsplit()`应用到一个字符串组成的向量上会返回一个列表：

```
> name <- strsplit((roster$Student), " ")
> name
[[1]]
[1] "John"  "Davis"

[[2]]
[1] "Angela"   "Williams"

[[3]]
[1] "Bullwinkle" "Moose"

[[4]]
[1] "David" "Jones"

[[5]]
[1] "Janice"     "Markhammer"

[[6]]
[1] "Cheryl"  "Cushing"

[[7]]
[1] "Reuven"  "Ytzrhak"

[[8]]
[1] "Greg" "Knox"

[[9]]
[1] "Joel"    "England"

[[10]]
[1] "Mary"    "Rayburn"

```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499075078322.png/wm)

**步骤 7**　你可以使用函数`sapply()`提取列表中每个成分的第一个元素，放入一个储存名字的向量`Firstname`，并提取每个成分的第二个元素，放入一个储存姓氏的向量`Lastname`。`"["`是一个可以提取某个对象的一部分的函数——在这里它是用来提取列表`name`各成分中的第一个或第二个元素的。你将使用`cbind()`把它们添加到花名册中。由于已经不再需要`student`变量，可以将其丢弃（在下标中使用 - 1）。

```
> Firstname <- sapply(name, "[", 1)
> Lastname <- sapply(name, "[", 2)
> roster <- cbind(Firstname, Lastname, roster[,-1])
> roster
      Firstname     Lastname    Math   Science   English score   grade
1          John        Davis    502      95        25    0.559     B
2        Angela     Williams    600      99        22    0.924     A
3    Bullwinkle        Moose    412      80        18   -0.857     D
4         David        Jones    358      82        15   -1.162     F
5        Janice   Markhammer    495      75        20   -0.629     D
6        Cheryl      Cushing    512      85        28    0.353     C
7        Reuven      Ytzrhak    410      80        15   -1.048     F
8          Greg         Knox    625      95        30    1.338     A
9          Joel      England    573      89        27    0.698     B
10         Mary      Rayburn    522      86        18   -0.177     C

```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499075138501.png/wm)

**步骤 8**　最后，可以使用函数`order()`依姓氏和名字对数据集进行排序：

```
> roster[order(Lastname,Firstname),]

      Firstname    Lastname      Math   Science   English score   grade
6        Cheryl     Cushing      512      85        28     0.35     C
1          John       Davis      502      95        25     0.56     B
9          Joel     England      573      89        27     0.70     B
4         David       Jones      358      82        15    -1.16     F
8          Greg        Knox      625      95        30     1.34     A
5        Janice  Markhammer      495      75        20    -0.63     D
3    Bullwinkle       Moose      412      80        18    -0.86     D
10         Mary     Rayburn      522      86        18    -0.18     C
2        Angela    Williams      600      99        22     0.92     A
7        Reuven     Ytzrhak      410      80        15    -1.05     F

```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499075147219.png/wm)

瞧！小事一桩！

完成这些任务的方式有许多，只是以上代码体现了相应函数的设计初衷。

现在到学习控制结构和自己编写函数的时候了。

## **3.3　控制流**

在正常情况下，R 程序中的语句是从上至下顺序执行的。但有时你可能希望重复执行某些语句，仅在满足特定条件的情况下执行另外的语句。这就是控制流结构发挥作用的地方了。

R 拥有一般现代编程语言中都有的标准控制结构。首先你将看到用于条件执行的结构，接下来是用于循环执行的结构。

为了理解贯穿本节的语法示例，请牢记以下概念：

- 语句（*statement*）是一条单独的 R 语句或一组复合语句（包含在花括号`{ }`中的一组 R 语句，使用分号分隔）；
- 条件（*cond*）是一条最终被解析为真（`TRUE`）或假（`FALSE`）的表达式；
- 表达式（*expr*）是一条数值或字符串的求值语句；
- 序列（*seq*）是一个数值或字符串序列。

在讨论过控制流的构造后，我们将学习如何编写函数。

### **3.3.1　重复和循环**

循环结构重复地执行一个或一系列语句，直到某个条件不为真为止。循环结构包括`for`和`while`结构。

**1. for结构**

`for`循环重复地执行一个语句，直到某个变量的值不再包含在序列`seq`中为止。语法为：

```
for (var in seq) statement



```

在下例中：

```
for (i in 1:10)  print("Hello")



```

单词 Hello 被输出了 10 次。

**2. while结构**

`while`循环重复地执行一个语句，直到条件不为真为止。语法为：

```
while (cond) statement



```

作为第二个例子，代码：

```
i <- 10
while (i > 0) {print("Hello"); i <- i - 1}



```

又将单词 Hello 输出了 10 次。请确保括号内`while`的条件语句能够改变，即让它在某个时刻不再为真——否则循环将永不停止！在上例中，语句：

```
i <- i - 1



```

在每步循环中为对象`i`减去 1，这样在十次循环过后，它就不再大于 0 了。反之，如果在每步循环都加 1 的话，R 将不停地打招呼。这也是`while`循环可能较其他循环结构更危险的原因。

在处理大数据集中的行和列时，R 中的循环可能比较低效费时。只要可能，最好联用 R 中的内建数值 / 字符处理函数和`apply`族函数。

### **3.3.2　条件执行**

在条件执行结构中，一条或一组语句仅在满足一个指定条件时执行。条件执行结构包括`if-else`、`ifelse`和`switch`。

**1. if-else结构**

控制结构`if-else`在某个给定条件为真时执行语句。也可以同时在条件为假时执行另外的语句。语法为：

```
if (cond) statement
if (cond) statement1 else statement2



```

示例如下：

```
if (is.character(grade)) grade <- as.factor(grade)
if (!is.factor(grade)) grade <- as.factor(grade) else print("Grade already is a factor")



```

在第一个实例中，如果`grade`是一个字符向量，它就会被转换为一个因子。在第二个实例中，两个语句择其一执行。如果`grade`不是一个因子（注意符号`!`），它就会被转换为一个因子。如果它是一个因子，就会输出一段信息。

**2. ifelse结构**

`ifelse`结构是`if-else`结构比较紧凑的向量化版本，其语法为：

```
ifelse(cond, statement1, statement2)



```

若`cond`为`TRUE`，则执行第一个语句；若`cond`为`FALSE`，则执行第二个语句。示例如下：

```
ifelse(score > 0.5, print("Passed"), print("Failed"))
outcome <- ifelse (score > 0.5, "Passed", "Failed")



```

在程序的行为是二元时，或者希望结构的输入和输出均为向量时，请使用`ifelse`。

**3. switch结构**

`switch`根据一个表达式的值选择语句执行。语法为：

```
switch(expr, ...)



```

其中的`...`表示与`expr`的各种可能输出值绑定的语句。通过观察代码清单 3-7 中的代码，可以轻松地理解`switch`的工作原理。

> **代码清单 3-6**　一个`switch`示例

```
> feelings <- c("sad", "afraid")
> for (i in feelings)
    print(
      switch(i,
        happy  = "I am glad you are happy",
        afraid = "There is nothing to fear",
        sad    = "Cheer up",
        angry  = "Calm down now"
      )
    )

[1] "Cheer up"
[1] "There is nothing to fear"

```

虽然这个例子比较幼稚，但它展示了`switch`的主要功能。你将在下一节学习如何使用`switch`编写自己的函数。

## **3.4　用户自编函数**

R 的最大优点之一就是用户可以自行添加函数。事实上，R 中的许多函数都是由已有函数构成的。一个函数的结构看起来大致如此：

```
myfunction <- function(arg1, arg2, ... ){
  statements
  return(object)
}



```

函数中的对象只在函数内部使用。返回对象的数据类型是任意的，从标量到列表皆可。让我们看一个示例。

假设你想编写一个函数，用来计算数据对象的集中趋势和散布情况。此函数应当可以选择性地给出参数统计量（均值和标准差）和非参数统计量（中位数和绝对中位差）。结果应当以一个含名称列表的形式给出。另外，用户应当可以选择是否自动输出结果。除非另外指定，否则此函数的默认行为应当是计算参数统计量并且不输出结果。代码清单 3-8 给出了一种解答。

> **代码清单 3-8**　`mystats()`：一个由用户编写的描述性统计量计算函数

```
mystats <- function(x, parametric=TRUE, print=FALSE) {
  if (parametric) {
    center <- mean(x); spread <- sd(x)
  } else {
    center <- median(x); spread <- mad(x)
  }
  if (print & parametric) {
    cat("Mean=", center, "\n", "SD=", spread, "\n")
  } else if (print & !parametric) {
    cat("Median=", center, "\n", "MAD=", spread, "\n")
  }
  result <- list(center=center, spread=spread)
  return(result)
}




```

要看此函数的实战情况，首先需要生成一些数据（服从正态分布的，大小为 500 的随机样本）：

```
set.seed(1234)
x <- rnorm(500)



```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499075192603.png/wm)

在执行语句：

```
y <- mystats(x)



```

之后，`y$center`将包含均值（0.001 84），`y$spread`将包含标准差（1.03），并且没有输出结果。如果执行语句：

```
y <- mystats(x, parametric=FALSE, print=TRUE)



```

`y$center`将包含中位数（-0.0207），`y$spread`将包含绝对中位差（1.001）。另外，还会输出以下结果：

```
Median= -0.0207
MAD= 1



```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499075213048.png/wm)

下面让我们看一个使用了`switch`结构的用户自编函数，此函数可让用户选择输出当天日期的格式。在函数声明中为参数指定的值将作为其默认值。在函数`mydate()`中，如果未指定`type`，则`long`将为默认的日期格式：

```
mydate <- function(type="long") {
  switch(type,
    long =  format(Sys.time(), "%A %B %d %Y"),
    short = format(Sys.time(), "%m-%d-%y"),
    cat(type, "is not a recognized type\n")
   )
}



```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499075317501.png/wm)

实战中的函数如下：

```
> mydate("long")
[1] "Monday July 14 2014"
> mydate("short")
[1] "07-14-14"
> mydate()
[1] "Monday July 14 2014"
> mydate("medium")
medium is not a recognized type

```

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid276733labid3161timestamp1499075230738.png/wm)

请注意，函数`cat()`仅会在输入的日期格式类型不匹配`"long"`或`"short"`时执行。使用一个表达式来捕获用户的错误输入的参数值通常来说是一个好主意。

有若干函数可以用来为函数添加错误捕获和纠正功能。你可以使用函数`warning()`来生成一条错误提示信息，用`message()`来生成一条诊断信息，或用`stop()`停止当前表达式的执行并提示错误。20.5 节将会更加详细地讨论错误捕捉和调试。

在创建好自己的函数以后，你可能希望在每个会话中都能直接使用它们。附录 B 描述了如何定制 R 环境，以使 R 启动时自动读取用户编写的函数。我们将在第 6 章和第 8 章中看到更多的用户自编函数示例。

你可以使用本节中提供的基本技术完成很多工作。第 20 章的内容更加详细地涵盖了控制流和其他编程主题。第 21 章涵盖了如何创建包。如果你想要探索编写函数的微妙之处，或编写可以分发给他人使用的专业级代码，个人推荐阅读这两章，然后阅读两本优秀的书籍，你可在本书末尾的参考文献部分找到：Venables & Ripley（2000）以及 Chambers（2008）。这两本书共同提供了大量细节和众多示例。

函数的编写就讲到这里。

## **四　实验总结**

本章总结了数十种用于处理数据的数学、统计和概率函数。我们看到了如何将这些函数应用到范围广泛的数据对象上，其中包括向量、矩阵和数据框。你学习了控制流结构的使用方法：用循环重复执行某些语句，或用分支在满足某些特定条件时执行另外的语句。然后你编写了自己的函数，并将它们应用到数据上。最后，我们探索了折叠、整合以及重构数据的多种方法。

既然已经集齐了数据塑形（没有别的意思）所需的工具，你就准备好告别第一部分并进入激动人心的数据分析世界了！在接下来的几章中，我们将探索多种将数据转化为信息的统计方法和图形方法。

- [立即购买《R 语言实战（第 2 版）》](http://www.ituring.com.cn/book/1699)